Chapter1. 연습문제 1-6

데드락을 피하는 방법
= 데드락이 발생하는 조건들 중 하나라도 깨면 됨
  
< 데드락 발생 조건 > ====> 데드락은 아래 세 가지 조건이 모두 만족해야 발생
1. 공유되는 자원이 두개 이상(예 : 스푼&포크 인스턴스)
2. 쓰레드가 하나의 공유 자원 역할의 쓰레드의 락을 취한 상태에서, 
    다른 공유 자원 역할의 쓰레드의 락을 취하러 간다. (예 : eat() 내부 로직)
3. 공유 자원 역할의 쓰레드의 락을 취하는 순서가 정해져 있지 않다. (예: EaterThread에서 생성자로 받은 인자를 left,right에 할당)
  

< 해결 방법 >  
1. 공유되는 자원을 없애거나 하나만 공유하게 바꾼다.
    1-1. 쓰레드 갯수 만큼 스푼,포크 인스턴스를 만들어서 각각 제공한다.
    1-2. 스푼 혹은 포크 인스턴스 둘 중 하나만을 공유하고 그 외는 각각 제공한다.(혹은 쓰레드 내부에서 각자 생성하게 구현)
  
2. 쓰레드가 하나의 락을 취한 상태에서 다른 락을 취하러 가지 않게 한다.
  
  클래스 객체 lock 사용 => eat() synchronized block (this) =>이러면 무한반복이기 때문에 먼저 획득한 쓰레드만 계속 돌아갈 것이다.
  ==> 데드락이 발생하는 원인인 Tool 클래스 인스턴스의 lock 을 취함으로써 single~을 구현한게 아니라, 
  데드락이 발생하지 않는 EaterThread 클래스 자체에 lock을 취하는 형태로 바꿈 = 성공
  ==> lock 취득 타깃 자체를 변경했기 때문에 synchronized (this) 를 eat() 에다 걸어도 되고 eat() 내부에 걸어도 됨 + eat 메서드 자체를 synchronized 메서드로 바꿔도 됨
  
3. 락 순서를 만든다.
  
===> ?? 말이 안되지 않나 이미 락의 순서가 있는데, 데드락이 존재한다.... 모르겠음